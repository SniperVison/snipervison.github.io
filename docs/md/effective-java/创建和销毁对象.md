### 一、创建与销毁对象

#### 1、用静态工厂方法代替构造器

```java
public static final Boolean TRUE = new Boolean(true);
public static final Boolean FALSE = new Boolean(false);

public static Boolean valueOf(boolean b) {
    return (b ? TRUE : FALSE);
 }
```

- 拥有名称，方便使用，如：```BigInteger.probablePrime```
- 不必每次调用的时候都创建一个新对象，如：```Boolean.valueOf(boolean)```
- 可以返回原返回类型的任何子类型的对象
- 所返回的对象的类可以随着每次调用而发生变化，这取决于静态工厂方法的参数值

```java
public static <E extends Enum<E>> EnumSet<E> noneOf(Class<E> elementType) {
    Enum<?>[] universe = getUniverse(elementType);
    if (universe == null)
        throw new ClassCastException(elementType + " not an enum");
    if (universe.length <= 64)
        return new RegularEnumSet<>(elementType, universe);
    else
        return new JumboEnumSet<>(elementType, universe);
}
```

- 方法返回的对象所属的类，在编写包含该静态工厂方法的类时可以不存在，构成服务提供者框架，如：JDBC

#### 2. 遇到多个构造器参数时要考虑使用构建器

优点：如果类的构造器或者静态工厂中具有多个(>=4) 参数,此时使用Builder模式很不错。
缺点：创建对象的开始稍微明细，在注重性能的场景下存在问题

#### 3. 用私有构造器或者枚举类型强化Singleton属性

- 使用 私有构造器 + 公有静态final域成员，但反射时无效

```java
//1. 使用公有静态final域成员 (反射能够入侵代码)
public static final SingletonTest INSTANCE = new SingletonTest();
private SingletonTest() {}
```

- 使用私有构造器 + 静态工厂方法，但多线程创建时，无效

```java
// 2. 使用静态工厂方法
public static final SingletonTest INSTANCE = new SingletonTest();
public static SingletonTest getInstance() {return INSTANCE;}
private SingletonTest() {}
```

- 使用枚举类实现，单例的最佳实现

```java
public enum SingletonTest2 {CAR,HOUSE,PEOPLE;}
```

- 序列化的时候会破坏单例模式，需要加上```transient```关键字，同时添加readResolve()方法

```java
private Object readResolve() {return INSTANCE;}
```

#### 4.通过私有构造器强化不可实例化的能力

- 不能使用抽象类来强制该类不可实例化，因为此类可以被子类实例化，同时子类可以实例化
- 显式创建私有构造器，并抛出异常，加上注释，如工具类。

```java
public class Collections {
    // Suppresses default constructor, ensuring non-instantiability.
    private Collections() {}
}  
```

#### 5.优先使用依赖注入来引用资源

- 静态工具类和Singleton类不适用于需要引用底层资源的类 (无法适配引入多个不同的资源)
- 当创建一个实例时，将该资源或工厂传给构造器/静态工厂/构建器中(即依赖注入的方式，提供良好的灵活性和可测试性)

#### 6.避免创建不必要的对象

- 当创建的对象不可变时，如```String``` ,```正则表达式```, ```适配器/视图(如java.util.Map#keySet)```
- 避免无意识的装箱

#### 7. 消除过期的对象引用（避免导致内存泄漏）

- 集合和数组中不需要的对象记得置空（如果集合或者数组不会被销毁的情况下）
- 缓存，如WeakHashMap(当key不被其他对象引用时，会被GC), ```java.util.LinkedHashMap#removeEldestEntry```
- 监听器和其他回调，确保回调立即被当做垃圾回收的最佳方法是只保存它们的弱引用（weak reference）
- 借助Head Profiler工具排查内存泄漏问题

#### 8. 避免使用终结方法(finalizer)和清除方法(Cleaner)

- 行为不稳定，性能降低，以及可移植性问题
- 被执行的时机不确定
- finalizer抛出的异常可以被恶意错误记录，导致GC异常
- 实现AutoCloseable接口，调用close()方法，如```try-with-resources ``` 进行终止

#### 9. try -with-resources 优先于 try-finally

### 二、对于所有对象都通用的方法

#### 10. 重写equals方法时请遵守通用约定

- 自反性
- 对称性
- 传递性
- 一致性
- 对于任何非null的引用值x, x.equals(null) 必须返回false

#### 11. 重写equals方法时需要同时重写hashCode方法

#### 12. 始终要重写toString方法

#### 13. 谨慎成功重写clone方法

- 不可变的类永远都不应该提供clone方法
