#### 1、用静态工厂方法代替构造器

```java
public static final Boolean TRUE = new Boolean(true);
public static final Boolean FALSE = new Boolean(false);

public static Boolean valueOf(boolean b) {
    return (b ? TRUE : FALSE);
 }
```

- 拥有名称，方便使用，如：```BigInteger.probablePrime```

- 不必每次调用的时候都创建一个新对象，如：```Boolean.valueOf(boolean)```

- 可以返回原返回类型的任何子类型的对象

- 所返回的对象的类可以随着每次调用而发生变化，这取决于静态工厂方法的参数值

```java
public static <E extends Enum<E>> EnumSet<E> noneOf(Class<E> elementType) {
    Enum<?>[] universe = getUniverse(elementType);
    if (universe == null)
        throw new ClassCastException(elementType + " not an enum");
    if (universe.length <= 64)
        return new RegularEnumSet<>(elementType, universe);
    else
        return new JumboEnumSet<>(elementType, universe);
}
```

- 方法返回的对象所属的类，在编写包含该静态工厂方法的类时可以不存在，构成服务提供者框架，如：JDBC

#### 2. 遇到多个构造器参数时要考虑使用构建器
优点：如果类的构造器或者静态工厂中具有多个(>=4) 参数,此时使用Builder模式很不错。
缺点：创建对象的开始稍微明细，在注重性能的场景下存在问题

#### 3. 用私有构造器或者枚举类型强化Singleton属性